---
title: "Secretsをシールする"
date: 2019-04-09T00:00:00-03:00
weight: 14
draft: false
---

<!--
First, let's delete the **database-credentials** Secret resource that was created with Kustomize earlier in this module and deployed to the *octank* namespace in the cluster. After this operation, the only Secret that should exist in that namespace will be that of the token generated by Kubernetes for the default service account associated with the *octank* namespace.
-->
まずは、このモジュールのはじめにKustomizeで *octank* 名前空間にデプロイされた **database-credentials** Secretリソースを削除しましょう。これを実行した後に、この名前空間に残っているSecretは *octank* 名前空間と紐づいたデフォルトのサービスアカウントのトークンだけのはずです。

```
kubectl delete secret database-credentials -n octank
kubectl get secret -n octank
```
Output:
{{< output >}}
NAME                  TYPE                                  DATA   AGE
default-token-gv8nr   kubernetes.io/service-account-token   3      2d23h
{{< /output >}}

<!--
Now, create the Secret and SealedSecret YAML manifests with Kubectl, Kustomize and Kubeseal.
-->
では、Kubectl、KustomizeそしてKubesealを使って、SecretとSealedSecretのYAMLマニフェストを作成します。
```
cd ~/environment/secrets
kubectl kustomize . > secret.yaml
kubeseal --format=yaml < secret.yaml > sealed-secret.yaml
```

<!--
An alternative approach is to fetch the public key from the controller and use it offline to seal your Secrets
-->
別の方法として、コントローラから公開鍵を取得しておいて、オフラインでSecretをシールする方法があります
```
kubeseal --fetch-cert > public-key-cert.pem
kubeseal --cert=public-key-cert.pem --format=yaml < secret.yaml > sealed-secret.yaml
```

<!--
View the contents of the regular Secret and the corresponding SealedSecret with the following commands:
-->
次のコマンドで通常のSecretと対になるSealedSecretの内容をみてみます:
```
cat secret.yaml 
cat sealed-secret.yaml 
```
Output of secret.yaml :
{{< output >}}
apiVersion: v1
data:
  password: VHJ1NXROMCE=
  username: YWRtaW4=
kind: Secret
metadata:
  name: database-credentials
  namespace: octank
type: Opaque
{{< /output >}}

Output of sealed-secret.yaml:
{{< output >}}
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  creationTimestamp: null
  name: database-credentials
  namespace: octank
spec:
  encryptedData:
    password: AgB3s2m3c2wzDmfyFXPgZWzXG2Ad2s2DF5K8H4Z . . .
    username: AgAHJTiY9kEQCgFw90i3H1mKPRkGKFr85wDCDxU . . .
  template:
    metadata:
      creationTimestamp: null
      name: database-credentials
      namespace: octank
    type: Opaque
status: {}
{{< /output >}}

<!--
Note that the keys in the original Secret, namely, *username* and *password*, are not encrypted in the SealedSecret; only their values. You may change the names of these keys, if necessary, in the SealedSecret YAML file and still be able to deploy it successfully to the cluster. However, you cannot change the name and namespace of the SealedSecret. The SealedSecret and Secret **must have the same namespace and name**
-->
SealedSecretでは元のSecretの値だけが暗号化され、キーである *username* と *password* は暗号化されていないことに注目してください。必要であれば、これらのキーの名前をSealedSecretのYAMLファイル上で変更できます。しかし、SealedSecretの名前と名前空間はあ変更できません。SecretとSealedSecretは **同じ名前と名前空間である必要があります**

<!--
Now, deploy the SealedSecret to your cluster:
-->
では、SealedSecretをクラスタにデプロイします:
```
kubectl apply -f sealed-secret.yaml 
```
<!--
Looking at the logs of the contoller, you can see that it picks up the SealedSecret custom resource that was just deployed, unseals it to create a regular Secret.
-->
コントローラのログを見ると、たった今デプロイしたSealedSecretのカスタムリソースを開封(unseal)し、通常のSecretを作成しているのがわかります。
```
kubectl logs sealed-secrets-controller-84fcdcd5fd-9qb5j -n kube-system
```
Output:
{{< output >}}
2020/03/07 22:11:20 Starting sealed-secrets controller version: v0.9.8
2020/03/07 22:11:20 Searching for existing private keys
2020/03/07 22:11:23 New key written to kube-system/sealed-secrets-key8d8z2
2020/03/07 22:11:23 Certificate is 
-----BEGIN CERTIFICATE-----
MIIErTCCApWgAwIBAgIQJsQQhEXabaLWTUIzkH+EeDANBgkqhkiG9w0BAQsFADAA
MB4XDTIwMDMwNzIyMTEyM1oXDTMwMDMwNTIyMTEyM1owADCCAiIwDQYJKoZIhvcN
. . . . .
Se0Lk6ZACjiFqNMdL/VkSG2pYkjdFg64KZzDLad7lBrB3tOtCW8xG5T8jZuzDewB
65pXxa+MvFjnfukUE3LfC1xM17pPjRQmJ5YgcQCXsTorFXHIw21t3mF6EZfuZgpJ
XA==
-----END CERTIFICATE-----

2020/03/07 22:11:23 HTTP server serving on :8080
2020/03/07 22:27:15 Updating octank/database-credentials
2020/03/07 22:27:15 Event(v1.ObjectReference{Kind:"SealedSecret", Namespace:"octank", Name:"database-credentials", UID:"cc4d3675-60c2-11ea-a6b7-0e57dc790b09", APIVersion:"bitnami.com/v1alpha1", ResourceVersion:"6403704", FieldPath:""}): type: 'Normal' reason: 'Unsealed' SealedSecret unsealed successfully
{{< /output >}}

<!--
Verfiy that the **database-credentials** Secret unsealed from the SealedSecret was deployed by the controller to the *octank* namespace.
-->
コントローラによってSealedSecretから開封されて*octank* 名前空間にデプロイされた **database-credentials** Secretを確認します。
```
kubectl get Secret database-credentials -n octank
```
{{< output >}}
NAME                   TYPE     DATA   AGE
database-credentials   Opaque   2      4m18s
{{< /output >}}

<!--
Redeploy the pod that reads from the above Secret and verify that the keys have been exposed as environment variables with the correct literal values.
-->
このSeccretを読み込むpodを再度デプロイして、キーが正しい文字列として環境変数に設定されているか確認します。
```
kubectl delete pod pod-variable -n octank
kubectl apply -f pod-variable.yaml -n octank
kubectl logs pod-variable -n octank
```
Output:
{{< output >}}
DATABASE_USER = admin
DATABASE_PASSWROD = Tru5tN0!
{{< /output >}}

<!--
The YAML file, **sealed-secret.yaml**, that pertains to the SealedSecret is safe to be stored in a Git repository along with YAML manifests pertaining to other Kubernetes resources such as DaemonSets, Deployments, ConfigMaps etc. deployed in the cluster. You can then use a [GitOps workflow](https://www.weave.works/technologies/gitops/) to manage the deployment of these resources to your cluster. The YAML file, **secret.yaml**, that pertains to the Secret may be deleted because it is never used in any subsequent workflows.
-->
SealedSecretが含まれた **sealed-secret.yaml** のYAMLファイルは、DaemonSet、Deployment、ConfigMapなどの他のKubernetesリソースのYAMLマニフェストと一緒にGitレポジトリに保存することができます。そのあとに、これらのリソースのデプロイメントの管理に[GitOps workflow](https://www.weave.works/technologies/gitops/)を使うこともできます。Secretを含む **secret.yaml** ファイルは、以降のワークフローでは使われないので、削除しても構いません。