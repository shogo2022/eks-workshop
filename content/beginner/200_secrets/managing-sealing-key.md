---
title: "封印キー(sealing key)の管理"
date: 2019-04-09T00:00:00-03:00
weight: 15
draft: false
---

SealedSecret内の暗号化されたデータを復号化するには、コントローラが管理している秘密鍵が必要不可欠です。災害後にクラスタを原状復旧させる場合や、GitOpsワークフローを使ってGitレポジトリから別のEKSクラスタをデプロイする場合などは、新しいクラスタにデプロイされたコントローラがSealedSecretを開封できるように同じ秘密鍵を使う必要があります。 

<!--
Run the following command in order to retrieve the private key from the cluster. In a production environment, you will typically make use of Kubernetes RBAC to grant the permissions required to perform this operation to restricted set of clients.
-->
次のコマンドは、クラスタから秘密鍵を取得します。商用環境では一般的に、 RBACでこのオペレーションをクライアントの一部だけに許可します。
```
kubectl get secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key -o yaml > master.yaml
```

<!--
To test how this works, let's first delete the installation of the controller, the Secret that it created which contains the private key, the SealedSecret resource named **database-credentials** as well as the Secret that was unsealed from it.
-->
これを試すために、まずはコントローラ、秘密鍵を含むSecret、 **database-credentials** というSealedSecret、そしてそこから作成されたSecretを削除しましょう。
```
kubectl delete secret database-credentials -n octank
kubectl delete sealedsecret database-credentials -n octank
kubectl delete secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key
kubectl delete -f controller.yaml 
```

<!--
Now, put the Secret containing the private key back into the cluster using the **master.yaml** file.
-->
では、秘密鍵を含むSecretである **master.yaml** を戻します。
```
kubectl apply -f master.yaml 
kubectl get secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key
```
Output:
{{< output >}}
NAME                      TYPE                DATA   AGE
sealed-secrets-keyvk4pr   kubernetes.io/tls   2      23s
{{< /output >}}


<!--
Next, redeploy the SealedSecret CRD, controller and RBAC artifacts on your EKS.
-->
次に、SealedSecret CRD、コントローラ、そしてRBACファイルを再度デプロイします。
```
kubectl apply -f controller.yaml
kubectl get pods -n kube-system | grep sealed-secrets-controller
```
Output:
{{< output >}}
sealed-secrets-controller-84fcdcd5fd-gznc2            0/1     ContainerCreating   0          2s
{{< /output >}}

<!--
View the logs of the newly launched controller pod. Note that the name of the controller pod will be different in your cluster.
-->
新しく起動したコントローラpodのログを確認します。コントローラの名前は自身のものに読み替えて下さい。
```
kubectl logs sealed-secrets-controller-84fcdcd5fd-ds5t6 -n kube-system
```

Output:
{{< output >}}
2020/03/07 23:07:15 Starting sealed-secrets controller version: v0.9.8
2020/03/07 23:07:15 Searching for existing private keys
2020/03/07 23:07:16 ----- sealed-secrets-keyvk4pr
2020/03/07 23:07:16 HTTP server serving on :8080
{{< /output >}}

<!--
As you can see from the logs, the controller was able to find the existing Secret **sealed-secrets-keyvk4pr** in the *kube-system* namespace and therefore does not create a new key pair. Now, let's redeploy the SealedSecret and verify that the controller is able to successfully unseal it.
-->
ログからわかるように、 *kube-system* 名前空間に既存のSecretである **sealed-secrets-keyvk4pr** が見つかったので、キーペアの新規作成は行われていません。では、SealedSecretを再度デプロイして、コントローラが問題なく開封できるか確認しましょう。
```
kubectl apply -f sealed-secret.yaml 
kubectl logs sealed-secrets-controller-84fcdcd5fd-gznc2  -n kube-system
```

Output:
{{< output >}}
2020/03/07 23:07:15 Starting sealed-secrets controller version: v0.9.8
2020/03/07 23:07:15 Searching for existing private keys
2020/03/07 23:07:16 ----- sealed-secrets-keyvk4pr
2020/03/07 23:07:16 HTTP server serving on :8080
2020/03/07 23:07:54 Updating octank/database-credentials
2020/03/07 23:07:54 Event(v1.ObjectReference{Kind:"SealedSecret", Namespace:"octank", Name:"database-credentials", UID:"7a27919c-60c8-11ea-a6b7-0e57dc790b09", APIVersion:"bitnami.com/v1alpha1", ResourceVersion:"6409442", FieldPath:""}): type: 'Normal' reason: 'Unsealed' SealedSecret unsealed successfully
{{< /output >}}

<!--
{{% notice info %}}
If the file **master.yaml** which contains the public/private key pair generated by the controller is compromised, then all the SealedSecret manifests can be unsealed and the encrypted sensitive information they store revealed. Hence, this file must be guarded by granting least privilege access. For additional guidance on sealing key renewal, manual sealing key management etc., please consult the [documentation](https://github.com/bitnami-labs/sealed-secrets#secret-rotation).

One option to secure the private key is to store the **master.yaml** file contents as a **SecureString** parameter in AWS Systems Manager Parameter Store. The parameter could be secured using a KMS Customer managed key (CMK) and you can use the Key policy to restrict the set of IAM principals who can use this key in order to retrieve the parameter. Additionally, you may also enable automatic rotation of this CMK in KMS. Note that Standard tier parameters support a maximum parameter value of 4096 characters. Hence, given the size of the **master.yaml** file, you will have to store it as a parameter in the Advanced tier.
{{% /notice %}}
-->
{{% notice info %}}
コントローラが生成した公開/秘密鍵ペアを含む **master.yaml** ファイルが漏洩した場合、全てのSealedSecretマニフェストと暗号化された機密情報は復号化されてしまいます。したがって、このファイルは最小限のアクセスのみが許可されるべきです。封印キー(sealing key)の更新や、手動でのキー管理などは[ドキュメント](https://github.com/bitnami-labs/sealed-secrets#secret-rotation)を参照してください。

秘密鍵を保護する一つの方法は、 **master.yaml** ファイルをAWS Systems Manager Parameter Storeに **SecureString** パラメータで保存することです。パラメータはKMSカスタマーマネージドキー(CMK)で保護され、キーポリシーでパラメータを取得するためにキーを使える人をIAMプリンシパルで制限することができます。 また、このCMKの自動更新もKMSでできます。Standard tierのパラメータは最大で4096文字の制限があります。 **master.yaml** ファイルのサイズを考えると、Advanced tierのパラメータとして保存する必要があります。
{{% /notice %}}